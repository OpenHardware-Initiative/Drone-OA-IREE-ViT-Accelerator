#include <iostream>
#include <vector>
#include <chrono>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cassert>

// --- Project-Specific Headers ---
#include "fpga_link.hpp"
#include "pre_processing.hpp"
#include "post_processing.hpp"

// --- IREE C API Headers ---
#include "iree/runtime/api.h"
#include "iree/hal/api.h"
#include "iree/hal/drivers/local_sync/sync_device.h"
#include "iree/hal/local/loaders/static_library_loader.h"

// --- Headers Generated by IREE (Names defined in CMakeLists.txt) ---
#include "ITAViTLSTM_c.h"
#include "ITAViTLSTM_static_lib.h"

#define IREE_CHECK_OK(status) assert(iree_status_is_ok(status))

// --- Forward Declarations ---
iree_status_t create_device_with_static_loader(iree_allocator_t host_allocator, iree_hal_device_t** out_device);
iree_status_t create_tensor_view(iree_hal_device_t* device, const void* data, const iree_hal_dim_t* shape, iree_host_size_t shape_rank, iree_hal_element_type_t element_type, iree_hal_buffer_view_t** out_buffer_view);

// --- Main Application ---
int main() {
    std::cout << "--- C++ IREE Inference Server for ITAViTLSTM ---" << std::endl;

    // --- 1. IREE Setup ---
    iree_runtime_instance_options_t instance_options;
    iree_runtime_instance_options_initialize(&instance_options);
    iree_runtime_instance_t* instance = NULL;
    IREE_CHECK_OK(iree_runtime_instance_create(&instance_options, iree_allocator_system(), &instance));

    iree_hal_device_t* device = NULL;
    IREE_CHECK_OK(create_device_with_static_loader(iree_runtime_instance_host_allocator(instance), &device));

    iree_runtime_session_options_t session_options;
    iree_runtime_session_options_initialize(&session_options);
    iree_runtime_session_t* session = NULL;
    IREE_CHECK_OK(iree_runtime_session_create_with_device(instance, &session_options, device, iree_runtime_instance_host_allocator(instance), &session));

    // --- 2. Load the Bytecode Module ---
    const struct iree_file_toc_t* module_file = ITAViTLSTM_create();
    iree_vm_module_t* bytecode_module = NULL;
    IREE_CHECK_OK(iree_vm_bytecode_module_create(
        iree_runtime_instance_vm_instance(instance),
        iree_make_const_byte_span(module_file->data, module_file->size),
        iree_allocator_null(), iree_allocator_system(), &bytecode_module));
    IREE_CHECK_OK(iree_runtime_session_append_module(session, bytecode_module));
    iree_vm_module_release(bytecode_module);

    // --- 3. Lookup the Stateful Inference Function ---
    const char* func_name = "module.main_graph";
    iree_runtime_call_t call;
    IREE_CHECK_OK(iree_runtime_call_initialize_by_name(session, iree_make_cstring_view(func_name), &call));

    // --- 4. Initialize Hidden State Tensors ---
    // Shape from MLIR is <3x1x128xf32>
    const iree_hal_dim_t hidden_shape[] = {3, 1, 128};
    const size_t hidden_element_count = 3 * 1 * 128;
    const size_t hidden_byte_size = hidden_element_count * sizeof(float);
    std::vector<char> zero_buffer(hidden_byte_size, 0);

    iree_hal_buffer_view_t* hidden_state_h = NULL;
    IREE_CHECK_OK(create_tensor_view(device, zero_buffer.data(), hidden_shape, 3, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &hidden_state_h));

    iree_hal_buffer_view_t* hidden_state_c = NULL;
    IREE_CHECK_OK(create_tensor_view(device, zero_buffer.data(), hidden_shape, 3, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &hidden_state_c));

    // --- 5. Setup UDP Server ---
    int sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    bind(sock_fd, (const struct sockaddr*)&server_addr, sizeof(server_addr));
    std::cout << "Network server running. Listening on port " << PORT << "..." << std::endl;

    // --- 6. Main Network and Inference Loop ---
    while (true) {
        std::vector<char> recv_buffer(sizeof(HostToFpgaPacket));
        socklen_t client_len = sizeof(client_addr);
        ssize_t n = recvfrom(sock_fd, recv_buffer.data(), recv_buffer.size(), 0, (struct sockaddr*)&client_addr, &client_len);

        if (n != sizeof(HostToFpgaPacket)) {
            std::cerr << "Warning: Received malformed packet of size " << n << std::endl;
            continue;
        }

        HostToFpgaPacket packet_in;
        if (!unpack_frame(recv_buffer, packet_in)) continue;

        // --- a. Prepare IREE Inputs ---
        iree_runtime_call_inputs_clear(&call);

        // Input 0: Image (pre-processed to float32)
        std::vector<float> image_f32 = pre_process_image(packet_in);
        const iree_hal_dim_t img_shape[] = {1, 1, 60, 90};
        iree_hal_buffer_view_t* img_view = NULL;
        IREE_CHECK_OK(create_tensor_view(device, image_f32.data(), img_shape, 4, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &img_view));
        IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, img_view));
        iree_hal_buffer_view_release(img_view);

        // Input 1: Desired Velocity
        const iree_hal_dim_t vel_shape[] = {1, 1};
        iree_hal_buffer_view_t* vel_view = NULL;
        IREE_CHECK_OK(create_tensor_view(device, &packet_in.desired_velocity, vel_shape, 2, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &vel_view));
        IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, vel_view));
        iree_hal_buffer_view_release(vel_view);

        // Input 2: Quaternion
        const iree_hal_dim_t quat_shape[] = {1, 4};
        iree_hal_buffer_view_t* quat_view = NULL;
        IREE_CHECK_OK(create_tensor_view(device, packet_in.quaternion, quat_shape, 2, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &quat_view));
        IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, quat_view));
        iree_hal_buffer_view_release(quat_view);

        // Input 3: Hidden State h
        IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, hidden_state_h));
        
        // Input 4: Hidden State c
        IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, hidden_state_c));

        // --- b. Invoke the model synchronously ---
        IREE_CHECK_OK(iree_runtime_call_invoke(&call, /*flags=*/0));

        // --- c. Retrieve Outputs and Update State ---
        iree_hal_buffer_view_t* raw_output_view = NULL;
        IREE_CHECK_OK(iree_runtime_call_outputs_pop_front_buffer_view(&call, &raw_output_view));

        iree_hal_buffer_view_t* new_hidden_state_h = NULL;
        IREE_CHECK_OK(iree_runtime_call_outputs_pop_front_buffer_view(&call, &new_hidden_state_h));
        
        iree_hal_buffer_view_t* new_hidden_state_c = NULL;
        IREE_CHECK_OK(iree_runtime_call_outputs_pop_front_buffer_view(&call, &new_hidden_state_c));
        
        // CRITICAL: Update state. Release old, keep the new one (which is already retained).
        iree_hal_buffer_view_release(hidden_state_h);
        hidden_state_h = new_hidden_state_h;
        iree_hal_buffer_view_release(hidden_state_c);
        hidden_state_c = new_hidden_state_c;

        // --- d. Post-process and Send Reply ---
        iree_hal_buffer_mapping_t mapped_memory;
        IREE_CHECK_OK(iree_hal_buffer_map_range(iree_hal_buffer_view_buffer(raw_output_view), IREE_HAL_MAPPING_MODE_SCOPED,
                                                IREE_HAL_MEMORY_ACCESS_READ, 0, IREE_WHOLE_BUFFER, &mapped_memory));

        FpgaToHostPacket packet_out;
        calculate_final_velocity((const float*)mapped_memory.contents.data, packet_in.desired_velocity, packet_in.position_x, packet_out);
        
        iree_hal_buffer_unmap_range(&mapped_memory); // Good practice to unmap
        iree_hal_buffer_view_release(raw_output_view); // Done with the output view

        std::vector<char> send_buffer = pack_reply(packet_out);
        sendto(sock_fd, send_buffer.data(), send_buffer.size(), 0, (const struct sockaddr*)&client_addr, client_len);
    }

    // --- Final Cleanup ---
    close(sock_fd);
    iree_runtime_call_deinitialize(&call);
    iree_hal_buffer_view_release(hidden_state_h);
    iree_hal_buffer_view_release(hidden_state_c);
    iree_runtime_session_release(session);
    iree_hal_device_release(device);
    iree_runtime_instance_release(instance);
    return 0;
}


// --- Helper Implementations ---
iree_status_t create_device_with_static_loader(iree_allocator_t host_allocator, iree_hal_device_t** out_device) {
    iree_hal_sync_device_params_t params;
    iree_hal_sync_device_params_initialize(&params);

    const iree_hal_executable_library_query_fn_t libraries[] = { ITAViTLSTM_static_lib_library_query };
    iree_hal_executable_loader_t* static_loader = NULL;
    IREE_CHECK_OK(iree_hal_static_library_loader_create(IREE_ARRAYSIZE(libraries), libraries, iree_hal_executable_import_provider_null(), host_allocator, &static_loader));

    iree_string_view_t identifier = iree_make_cstring_view("local-sync");
    iree_hal_allocator_t* device_allocator = NULL;
    IREE_CHECK_OK(iree_hal_allocator_create_heap(identifier, host_allocator, host_allocator, &device_allocator));
    
    IREE_CHECK_OK(iree_hal_sync_device_create(identifier, &params, 1, &static_loader, device_allocator, host_allocator, out_device));
    
    iree_hal_allocator_release(device_allocator);
    iree_hal_executable_loader_release(static_loader);
    return iree_ok_status();
}

iree_status_t create_tensor_view(iree_hal_device_t* device, const void* data, const iree_hal_dim_t* shape, iree_host_size_t shape_rank, iree_hal_element_type_t element_type, iree_hal_buffer_view_t** out_buffer_view) {
    iree_hal_buffer_params_t buffer_params = {0};
    buffer_params.type = IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL;
    buffer_params.usage = IREE_HAL_BUFFER_USAGE_DEFAULT;
    iree_host_size_t byte_length = 0;
    IREE_CHECK_OK(iree_hal_buffer_view_compute_size_and_stride(shape_rank, shape, element_type, IREE_HAL_ENCODING_TYPE_DENSE_ROW_MAJOR, &byte_length, NULL));
    return iree_hal_buffer_view_allocate_buffer_copy(device, iree_hal_device_allocator(device), shape_rank, shape, element_type, IREE_HAL_ENCODING_TYPE_DENSE_ROW_MAJOR, buffer_params, iree_make_const_byte_span(data, byte_length), out_buffer_view);