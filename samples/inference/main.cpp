// src/test_inference_with_data.cpp
#include <iostream>
#include <vector>
#include <string>
#include <filesystem> // For iterating through files
#include <fstream>    // For reading the CSV
#include <sstream>    // For parsing CSV lines
#include <cassert>

// --- IREE C API Headers ---
#include "iree/runtime/api.h"
#include "iree/hal/api.h"
#include "iree/hal/drivers/local_sync/sync_device.h"
#include "iree/hal/local/loaders/static_library_loader.h"

// --- Headers Generated by IREE ---
#include "ITAViTLSTM_c.h"
#include "ITAViTLSTM_static_lib.h"

// --- Image Loading Library ---
#define STB_IMAGE_IMPLEMENTATION
#include "include/stb_image.h"

#define IREE_CHECK_OK(status) assert(iree_status_is_ok(status))

// --- Data Structures ---
struct TelemetryData {
    float desired_velocity;
    float quaternion[4];
};

// --- Forward Declarations ---
iree_status_t create_device_with_static_loader(iree_allocator_t host_allocator, iree_hal_device_t** out_device);
iree_status_t create_tensor_view(iree_hal_device_t* device, const void* data, const iree_hal_dim_t* shape, iree_host_size_t shape_rank, iree_hal_element_type_t element_type, iree_hal_buffer_view_t** out_buffer_view);
void print_output_tensor(iree_hal_buffer_view_t* view);
bool load_telemetry_for_image(const std::filesystem::path& csv_path, const std::string& image_timestamp, TelemetryData& out_telemetry);

// --- Main Application ---
int main(int argc, char** argv) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " /path/to/data/folder" << std::endl;
        return 1;
    }
    std::filesystem::path data_dir(argv[1]);

    // --- 1. Load Data From Files ---
    std::cout << "Loading data from: " << data_dir << std::endl;
    std::filesystem::path image_path, csv_path;
    std::string image_timestamp;

    // Find the first PNG and the CSV file
    for (const auto& entry : std::filesystem::directory_iterator(data_dir)) {
        if (entry.path().extension() == ".png" && image_path.empty()) {
            image_path = entry.path();
            image_timestamp = image_path.stem().string();
        }
        if (entry.path().filename() == "data.csv") {
            csv_path = entry.path();
        }
    }

    if (image_path.empty() || csv_path.empty()) {
        std::cerr << "Error: Could not find a .png file and/or data.csv in the specified directory." << std::endl;
        return 1;
    }

    // Load image using stb_image
    int width, height, channels;
    unsigned char *image_data_uint8 = stbi_load(image_path.c_str(), &width, &height, &channels, 1); // Force 1 channel (grayscale)
    if (!image_data_uint8) {
        std::cerr << "Error: Failed to load image " << image_path << std::endl;
        return 1;
    }
    std::cout << "Loaded image: " << image_path.filename() << " (" << width << "x" << height << ")" << std::endl;

    // Pre-process image to float32, normalized to [0, 1]
    std::vector<float> image_f32(width * height);
    for (int i = 0; i < width * height; ++i) {
        image_f32[i] = static_cast<float>(image_data_uint8[i]) / 255.0f;
    }
    stbi_image_free(image_data_uint8);

    // Load corresponding telemetry from CSV
    TelemetryData telemetry;
    if (!load_telemetry_for_image(csv_path, image_timestamp, telemetry)) {
        std::cerr << "Error: Could not find telemetry for timestamp " << image_timestamp << " in " << csv_path << std::endl;
        return 1;
    }
    std::cout << "Loaded telemetry: Desired Vel=" << telemetry.desired_velocity << std::endl;

    // --- 2. IREE Setup ---
    iree_runtime_instance_options_t instance_options;
    iree_runtime_instance_options_initialize(&instance_options);
    iree_runtime_instance_t* instance = NULL;
    IREE_CHECK_OK(iree_runtime_instance_create(&instance_options, iree_allocator_system(), &instance));

    iree_hal_device_t* device = NULL;
    IREE_CHECK_OK(create_device_with_static_loader(iree_runtime_instance_host_allocator(instance), &device));

    iree_runtime_session_options_t session_options;
    iree_runtime_session_options_initialize(&session_options);
    iree_runtime_session_t* session = NULL;
    IREE_CHECK_OK(iree_runtime_session_create_with_device(instance, &session_options, device, iree_runtime_instance_host_allocator(instance), &session));

    // --- 3. Load Model ---
    const struct iree_file_toc_t* module_file = ITAViTLSTM_create();
    iree_vm_module_t* bytecode_module = NULL;
    IREE_CHECK_OK(iree_vm_bytecode_module_create(iree_runtime_instance_vm_instance(instance), iree_make_const_byte_span(module_file->data, module_file->size), iree_allocator_null(), iree_allocator_system(), &bytecode_module));
    IREE_CHECK_OK(iree_runtime_session_append_module(session, bytecode_module));
    iree_vm_module_release(bytecode_module);

    // --- 4. Get Function and Initialize State ---
    const char* func_name = "module.main_graph";
    iree_runtime_call_t call;
    IREE_CHECK_OK(iree_runtime_call_initialize_by_name(session, iree_make_cstring_view(func_name), &call));

    const iree_hal_dim_t hidden_shape[] = {3, 1, 128};
    const size_t hidden_byte_size = 3 * 1 * 128 * sizeof(float);
    std::vector<char> zero_buffer(hidden_byte_size, 0);
    iree_hal_buffer_view_t* hidden_state_h = NULL;
    IREE_CHECK_OK(create_tensor_view(device, zero_buffer.data(), hidden_shape, 3, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &hidden_state_h));
    iree_hal_buffer_view_t* hidden_state_c = NULL;
    IREE_CHECK_OK(create_tensor_view(device, zero_buffer.data(), hidden_shape, 3, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &hidden_state_c));

    // --- 5. Prepare Tensors from Loaded Data ---
    const iree_hal_dim_t img_shape[] = {1, 1, 60, 90};
    iree_hal_buffer_view_t* img_view = NULL;
    IREE_CHECK_OK(create_tensor_view(device, image_f32.data(), img_shape, 4, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &img_view));

    const iree_hal_dim_t vel_shape[] = {1, 1};
    iree_hal_buffer_view_t* vel_view = NULL;
    IREE_CHECK_OK(create_tensor_view(device, &telemetry.desired_velocity, vel_shape, 2, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &vel_view));

    const iree_hal_dim_t quat_shape[] = {1, 4};
    iree_hal_buffer_view_t* quat_view = NULL;
    IREE_CHECK_OK(create_tensor_view(device, telemetry.quaternion, quat_shape, 2, IREE_HAL_ELEMENT_TYPE_FLOAT_32, &quat_view));

    // --- 6. Invoke ---
    iree_runtime_call_inputs_clear(&call);
    IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, img_view));
    IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, vel_view));
    IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, quat_view));
    IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, hidden_state_h));
    IREE_CHECK_OK(iree_runtime_call_inputs_push_back_buffer_view(&call, hidden_state_c));

    std::cout << "Invoking the model with real data..." << std::endl;
    IREE_CHECK_OK(iree_runtime_call_invoke(&call, /*flags=*/0));

    // --- 7. Print Outputs ---
    iree_hal_buffer_view_t* raw_output_view = NULL;
    IREE_CHECK_OK(iree_runtime_call_outputs_pop_front_buffer_view(&call, &raw_output_view));
    iree_hal_buffer_view_t* new_hidden_state_h = NULL;
    IREE_CHECK_OK(iree_runtime_call_outputs_pop_front_buffer_view(&call, &new_hidden_state_h));
    iree_hal_buffer_view_t* new_hidden_state_c = NULL;
    IREE_CHECK_OK(iree_runtime_call_outputs_pop_front_buffer_view(&call, &new_hidden_state_c));

    std::cout << "\n--- Inference Results ---" << std::endl;
    print_output_tensor(raw_output_view);
    std::cout << "-------------------------" << std::endl;

    // --- 8. Cleanup ---
    // (Cleanup code is identical to the dummy data test)
    return 0;
}

// --- Helper Implementations ---
bool load_telemetry_for_image(const std::filesystem::path& csv_path, const std::string& image_timestamp, TelemetryData& out_telemetry) {
    std::ifstream file(csv_path);
    if (!file.is_open()) return false;

    std::string line;
    // Skip header line
    std::getline(file, line);

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string cell;
        std::vector<std::string> row;
        while (std::getline(ss, cell, ',')) {
            row.push_back(cell);
        }

        // Compare the timestamp (column 1 in your CSV)
        if (row.size() > 6 && row[1] == image_timestamp) {
            out_telemetry.desired_velocity = std::stof(row[2]);
            out_telemetry.quaternion[0] = std::stof(row[3]);
            out_telemetry.quaternion[1] = std::stof(row[4]);
            out_telemetry.quaternion[2] = std::stof(row[5]);
            out_telemetry.quaternion[3] = std::stof(row[6]);
            return true;
        }
    }
    return false; // Not found
}

// --- Helper Implementations ---
// (These are identical to the server versions)

iree_status_t create_device_with_static_loader(iree_allocator_t host_allocator, iree_hal_device_t** out_device) {
    iree_hal_sync_device_params_t params;
    iree_hal_sync_device_params_initialize(&params);

    const iree_hal_executable_library_query_fn_t libraries[] = { ITAViTLSTM_static_lib_library_query };
    iree_hal_executable_loader_t* static_loader = NULL;
    IREE_CHECK_OK(iree_hal_static_library_loader_create(IREE_ARRAYSIZE(libraries), libraries, iree_hal_executable_import_provider_null(), host_allocator, &static_loader));

    iree_string_view_t identifier = iree_make_cstring_view("local-sync");
    iree_hal_allocator_t* device_allocator = NULL;
    IREE_CHECK_OK(iree_hal_allocator_create_heap(identifier, host_allocator, host_allocator, &device_allocator));
    
    IREE_CHECK_OK(iree_hal_sync_device_create(identifier, &params, 1, &static_loader, device_allocator, host_allocator, out_device));
    
    iree_hal_allocator_release(device_allocator);
    iree_hal_executable_loader_release(static_loader);
    return iree_ok_status();
}

iree_status_t create_tensor_view(iree_hal_device_t* device, const void* data, const iree_hal_dim_t* shape, iree_host_size_t shape_rank, iree_hal_element_type_t element_type, iree_hal_buffer_view_t** out_buffer_view) {
    iree_hal_buffer_params_t buffer_params = {0};
    buffer_params.type = IREE_HAL_MEMORY_TYPE_DEVICE_LOCAL;
    buffer_params.usage = IREE_HAL_BUFFER_USAGE_DEFAULT;
    iree_host_size_t byte_length = 0;
    IREE_CHECK_OK(iree_hal_buffer_view_compute_size_and_stride(shape_rank, shape, element_type, IREE_HAL_ENCODING_TYPE_DENSE_ROW_MAJOR, &byte_length, NULL));
    return iree_hal_buffer_view_allocate_buffer_copy(device, iree_hal_device_allocator(device), shape_rank, shape, element_type, IREE_HAL_ENCODING_TYPE_DENSE_ROW_MAJOR, buffer_params, iree_make_const_byte_span(data, byte_length), out_buffer_view);
}

void print_output_tensor(iree_hal_buffer_view_t* view) {
    if (!view) {
        std::cout << "  <null>" << std::endl;
        return;
    }

    // Map the buffer so we can read it on the host
    iree_hal_buffer_mapping_t mapped_memory;
    IREE_CHECK_OK(iree_hal_buffer_map_range(iree_hal_buffer_view_buffer(view), IREE_HAL_MAPPING_MODE_SCOPED,
                                             IREE_HAL_MEMORY_ACCESS_READ, 0, IREE_WHOLE_BUFFER, &mapped_memory));

    const float* data_ptr = reinterpret_cast<const float*>(mapped_memory.contents.data);
    iree_host_size_t element_count = iree_hal_buffer_view_element_count(view);

    std::cout << "  Output Tensor (Shape: ";
    for (int i = 0; i < iree_hal_buffer_view_shape_rank(view); ++i) {
        std::cout << iree_hal_buffer_view_shape_dim(view, i) << (i < iree_hal_buffer_view_shape_rank(view) - 1 ? "x" : "");
    }
    std::cout << ", Type: f32):" << std::endl;
    
    std::cout << "  [";
    for (iree_host_size_t i = 0; i < element_count; ++i) {
        std::cout << data_ptr[i] << (i < element_count - 1 ? ", " : "");
    }
    std::cout << "]" << std::endl;

    iree_hal_buffer_unmap_range(&mapped_memory);
}